# 魔曰 细节和使用指南

![License](https://img.shields.io/github/license/SheepChef/Abracadabra?color=yellow)

**Abracadabra(魔曰)** 是一个用于加密短文本/链接的工具。

其主要目的是为了防范各种平台上的关键词审查，以及基于语义的人工智能审查。

## 密本安全

魔曰的密本不同于任何同类型的工具，它由数百个《通用规范汉字表》中的一级字和二级字构成，也有一些非常常见的 **日本和制汉字(Kanji)**，比如 **桜(Sakura)**；但没有任何可能造成关键词屏蔽的汉字，也不存在笔画超过二十二画的生僻字。

为了增加审查难度，本工具的密表中主要涵盖自然鸟名(鸢/鹤/莺/鸳/鸯/鹂/雀)，自然植物名(兰/竹)，自然事物(灯/花/火/铃/琴/月...)

**您可能要问：它是如何增加审核难度的？**

本工具的核心目标在于 **增加审核的成本到不可接受的程度**，由于使用的所有汉字都是汉语中的常用字，机械屏蔽它们中的任何一个或几个都会导致日常/专业交流中灾难性的词汇缺失，以至于不得不被叫停。密本也不存在组成敏感关键词的可能，关键词识别将不会奏效。

基于人工智能的识别也显然完全无法理解这些字符的含义，因为它们仅包含随机汉字，无法组成任何意义连贯的文字。

我(开发者)使用 ChatGPT 和文心一言做过测试，测试显然成功，即使是资源开销很大的大语言模型也对这类密文无从下手，仅能给出十分模糊的判断意见。

比起任何一种密文单一且全是生僻字的类似工具，魔曰加密做到了优秀水准。

## 随机性

相同原文，相同密钥的情况下，本程序的加密结果随机性很高，不同于其他类似工具的单一密文。

随机性可以显著增强本工具的抗审查性能，使得针对密文的模式审查难以奏效。

在明文和密钥都一样的情况下，每次加密出来的密文可以说是**完全不同**。

### 传统加密随机性

第一重随机性来源于 AES-256-CTR 的两字节初始化向量，能够提供 256×256 共 65536 种可能密文。

第二重随机性则来源于密本(不考虑转轮)，每个字符至少有 10 种加密可能，即第二重随机性为 10^N。

最终的密文可能性为 65536*10^N，N为Base64字符串长度(近似正比于原文字节数)。

### 仿真加密随机性

第一重随机性来源于 AES-256-CTR 的两字节初始化向量，能够提供 256×256 共 65536 种可能密文。

第二重随机性则来源于密本和句式(不考虑转轮)，每个字符至少有 3 种加密可能，即第二重随机性为 3^N。

句式本身引入的虚词也提供相当的随机性。

不考虑句式虚词，最终的密文可能性为 65536*3^N，考虑虚词则更高。

## 加密安全

### AES-256

AES-256 是业内公认的安全加密算法，久经考验。

魔曰使用 AES-256-CTR 作为密文的核心加密方案，使得密文的安全性有基本的保证。

唯一的不足之处在于初始化向量(IV)的长度，标准长度是 16 字节，但是由于本项目的密文长度必须尽可能地短，便把 IV 长度压缩至两个字节，提供 65536 种随机性，配合转轮混淆，在大多数情况下足够安全。

由于IV(nounce)随机性被削减，可能发生CTR流密钥重用问题。

**如果没有混淆操作**，相同密钥加密出的密文有 N(相同密钥加密的有效密文数量)/65535 的可能导致明文的异或值泄露。

密钥参与的古典转轮混淆很大程度上避免了此问题，如果你在意安全性，请尽可能使用不同的密钥来加密。

### 转轮混淆

有关转轮混淆的细节，请见 [**Issue#30**](https://github.com/SheepChef/Abracadabra/issues/30)

## 传统加密标志位

标志位用来简化加解密操作流程，程序识别到加密标志位便会自动解密，无需用户手动指定解密，提高便利性。

但标志位会引入少许密文特征，虽然被针对性识别的可能性很低，但本项目仍然增加了加密时不添加标志位的选项，提供更好的抗审查能力。如果未来发生任何标志位的针对性检查，会酌情考虑移除它。

没有标志位的密文，在自动模式下将默认被再次加密，你需要手动指定强制解密。

## 文言仿真器

文言仿真，本质上是一种隐写。

仿真密文“载荷子”采用单字。载荷子和提前编写好的句式模板构成一个语块，每个句式都有一个固定载荷容量。

在生成密文的时候，会按照和传统一致的策略，对数据进行压缩，加密。然后使用一个特定算法来选取句式。

分析句式中所有有效载荷的属性(形容词，名词，动词等)和顺序，然后配合三重轮转来匹配选取载荷子，配合标点符号(可选)，最终组成一个合法密文。

生成出的密文符合古文语法，上下文有似是而非的逻辑关系。

有关文言仿真的更多细节，请见 [**Issue#60**](https://github.com/SheepChef/Abracadabra/issues/60)

## 压缩算法

项目使用专门针对短文本优化的 [**Unishox2**](https://github.com/siara-cc/Unishox2) 压缩算法，避免了通用压缩算法(如 GZIP 等)文件头过重的问题。

针对链接和常见域名编排了字典，有效提高特定链接(例如网盘链接)的压缩效率。

## 错误校验

项目使用轻量化的 [**卢恩算法**](https://zh.wikipedia.org/zh-cn/%E5%8D%A2%E6%81%A9%E7%AE%97%E6%B3%95)(US2950048， ISO/IEC 7812-1) 来对解密结果做简单校验，能够检出 70%的错误。

卢恩算法比起 Hmac 和 AES-GCM，安全性稍弱，但它十分轻量，校验位仅占一个字节。

## 跨平台

魔曰加密是一个跨平台的项目，以 JavaScript 实现，提供 WebAssembly 模块。

目前项目的 Demo 页已经开源，并且我(开发者)自认为它制作精美，拥有完善的配套功能和美观的视觉体验，且支持 PWA，可以安装到本地离线使用。

Demo 页使用 Vue 构建，你可以随时下载源码，在你喜欢的地方轻易地部署它。

## 最佳操作实践(传统加密)

下面列出一些情况下的最佳实践。

### 安全优先

如果你需要最高的安全性，则在加密时设置一个尽可能长和复杂的密码。

最好勾选“去除标志”，来让密文不存在任何可以被识别的特征。

解密时将需要对方勾选强制解密。

### 效率优先

你可以不填密码，这将会使程序自动用内部的默认密码`ABRACADABRA`加/解密。

把密文的识别交给标志位，这么做可以让他人很方便地解密。

### 混杂

你可以把密文夹杂在一个常规的文本中来增加隐蔽性。

但是注意不要在密文中增加或删除任何字(这会影响转轮解密步骤，导致密文损坏)。

## 最佳操作实践(仿真加密)

下面列出一些情况下的最佳实践。

### 仿真随机性

用户在菜单中可以通过滑条来选择句式的随机程度。
如果想要降低AI“判定出密文”的概率，那么请调整至"长句优先"，挑选句式的时候会优先使用最长的可用句。
句子越长，逻辑性也越强，但加密随机性可能受影响。

如果想要更随机，语块长短不一的密文，则推荐选择“适中”或更高。

### 语义通顺

如果嫌生成的句子过于生硬，不妨多次尝试生成(多点几下加密)，选择一个看起来最好的密文。
只要密钥和原文相同，生成出的所有密文均可以正常解密。

